# CPE-487-Final-Project-Tic-Tac-Toe
* Program the FPGA to display a Tic-Tac-Toe Game.
  * The Digilent Nexys A7-100T board has a female [VGA connector](https://en.wikipedia.org/wiki/VGA_connector) that can be connected to a VGA monitor via a VGA cable or a [High-Definition Multimedia Interface](https://en.wikipedia.org/wiki/HDMI) (HDMI) monitor via a [VGA-to-HDMI converter](https://www.ventioncable.com/product/vga-to-hdmi-converter/) with a [micro-B USB](https://en.wikipedia.org/wiki/USB_hardware) power supply.
  * [VGA video](https://web.mit.edu/6.111/www/s2004/NEWKIT/vga.shtml) uses separate wires to transmit the three color component signals and vertical and horizontal synchronization signals.
  * [Horizontal blanking interval](https://en.wikipedia.org/wiki/Horizontal_blanking_interval) consists of front porch, sync pulse, and back porch.
  * [Color mixing](https://en.wikipedia.org/wiki/Color_mixing) of the red and green lights is yellow, the green and blue lights is cyan, and the blue and red lights is magenta. In the absence of light of any color, the result is black. If all three primary colors of light are mixed in equal proportions, the result is neutral (gray or white).

* 2019-11-03 pull request by Peter Ho with the 800x600@60Hz support for 100MHz clock
  * The Xilinx [Clocking Wizard](https://www.xilinx.com/products/intellectual-property/clocking_wizard.html)
  * [7 Series FPGAs Clocking Resources User Guide](https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf)
  * CLKOUT0_DIVIDE_F in Line 124 of clk_wiz_0_clk_wiz.vhd was updated from 25.3125 to 25.25 because it shall be a multiple of 0.125

* The **_vga_sync_** module uses a clock to drive horizontal and vertical counters h_cnt and v_cnt, respectively.
  * These counters are then used to generate the various timing signals.
  * The vertical and horizontal sync waveforms, vsync and hsync, will go directly to the VGA display with the column and row address, pixel_col and pixel_row, of the current [pixel](https://en.wikipedia.org/wiki/Pixel) being displayed.
  * This module also takes as input the current red, green, and blue video data and gates it with a signal called video_on.
  * This ensures that no video is sent to the display during the sync and blanking periods.
  * Note that red, green, and blue video are each represented as 1-bit (on-off) quantities.
  * This is sufficient resolution for our application.

* The **_game_** module will be used to generate the red, green, and blue video that will paint the ball on to the VGA display at its current position.
  * This module maintains signals ball_x and ball_y that represent the current position of the ball on the screen.
  * These are initialized to (400, 300) to start the ball in the center of the screen.
  * The module also maintains a signal ball_y_motion that represents the number of pixels that the ball should move in one frame period.
  * This is initialized to +4 pixels/frame.
  * The module generates one-bit red, green, and blue video signals that are normally all set to 1.
  * This produces a white screen background.
  * When the signal ball_on is set, the green and blue signals go to 0 that makes those pixels red.
  * The module takes as input the current pixel row and column address that is generated by the vga_sync module.
  * Whenever the ball position is within 8 pixels of the current pixel address (in both x and y directions), the process bdraw sets the signal ball_on.
  * This paints a red ball around the current pixel address.
  * A second process mball (activated by the vsync signal) updates the ball position once every frame.
  * When the ball reaches the top of the screen, it changes the ball motion to -4 pixels per frame.
  * When it reaches the bottom of the screen it changes the ball motion to +4 pixels per frame.

* The **_vga_top_** module will connect the **_vga_sync_** and **_ball_** modules together and connect the appropriate signals to the board.

### 1. Description
### 2. 

### 3. Run implementation and open implemented design

### 4. Generate bitstream, open hardware manager, and program device

* Click 'Generate Bitstream'

* Click 'Open Hardware Manager' and click 'Open Target' then 'Auto Connect'

* Click 'Program Device' then xc7a100t_0 to download vga_top.bit to the Nexys A7 board

### 5. Edit code with the following modifications (this will be your Lab 3 Extension/Submission!)

* Change the size and color of the ball

* Change the square ball to a round ball

* Introduce a new signal ball_x_motion to allow the ball to move both horizontally and vertically






## Submission:
* Your final submission should be a github repository of very similar format to the labs themselves with an opening README document with the expected components as follows:
	* A description of the expected behavior of the project, attachments needed (speaker module, VGA connector, etc.), related images/diagrams, etc.
		* The more detailed the better – you all know how much I love a good finite state machine and Boolean logic, so those could be some good ideas if appropriate for your system. If not, some kind of high level block diagram showing how different parts of your program connect together and/or showing how what you have created might fit into a more complete system could be appropriate instead.
	* A summary of the steps to get the project to work in Vivado and on the Nexys board
	* Images and/or videos of the project in action interspersed throughout to provide context
	* “Modifications”
		* If building on an existing lab or expansive starter code of some kind, describe your “modifications” – the changes made to that starter code to improve the code, create entirely new functionalities, etc. Please share any starter code used as well.
		* If you truly created your code/project from scratch, describe that in brief here.
	* Conclude with a summary of the process itself – who was responsible for what components (preferably also shown by each person contributing to the github repository!), the timeline of work completed, any difficulties encountered and how they were solved, etc.
* And of course, the code itself separated into appropriate .vhd and .xdc files.
* You are not really expected to be github experts – as long as one of you can confidently create the repository and help others add to it, that should be sufficient. If no group members fall under this criteria, discuss with me as soon as possible.

Additionally, as discussed in class, you’ll be expected to give a demonstration + presentation during the final exam period. This can take the form of a live demonstration + informal discussion (the encouraged option in most situations that will be given more leeway from any technical difficulties), or a pre-created video including the project in action + slides describing much of the same content as the github submission (a backup option primarily for groups that will be missing multiple members during the final exam period).

## Extra Notes:

* If you need a single copy of any of the hardware (attachments) we use during the course, that should not be an issue. If you need multiple copies, there may be some “wait and see” situations and/or you may have minimal time to test the full implementation with all components.
* For more complex projects that would require hardware that you do not already readily have access to, it is sufficient to model the desired final system in some way. For example, showing the output of a controller for a microwave or other digital system on the LCD screen instead of actually controlling a microwave.
	* That said, if you already own these needed components, by all means use them!
* If you are still “attached” to a particular lab (calculator, pong, etc.), you may still explore these areas further with additional functionality (many more operations for a calculator, multiple players or other modifications for pong, etc.)
	* However, the above would fall under the “simple” category for project complexity. “Simple” projects (especially for groups of 3 students) will face additional scrutiny in the documentation and code. This isn’t meant to be a deterrent, but it is only fair that more ambitious projects have a bit more leeway if one section of the code isn’t working as anticipated, the documentation is a little sparse, etc.
